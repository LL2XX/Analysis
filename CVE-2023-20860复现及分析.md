# CVE-2023-20860复现及分析

## 漏洞原理
根据官网的[描述](https://spring.io/security/cve-2023-20860)，当Spring Security使用mvcRequestMatcher配置并将**作为匹配模式时，在Spring Security 和 Spring MVC 之间会发生模式不匹配，最终可能导致身份认证绕过

## 漏洞复现
> 影响版本：Spring Framework
> \>= 6.0.0, < 6.0.7
> \>= 5.3.0, < 5.3.26

实现几个控制器/admin、/hello、/admin/hello

Spring Security配置通过mvcMatchers匹配路径认证，**路径匹配需要认证，其他不需要
> ![Security配置](Security.png)

访问/admin、/hello、/admin/hello，均可访问，权限配置无效
> ![绕过](admin.png)

修改配置为/\*\*，配置成功，路径需要认证
> ![403](403.png)

## 漏洞分析
### Spring Security过滤器
Spring Security是基于过滤器的安全框架
> ![Security过滤器](filter.png)

进入到Spring Security过滤器后，首先会获取配置的过滤器链，而后按顺序执行过滤
> org.springframework.security.web.FilterChainProxy#doFilterInternal
> ![过滤](filters.png)

认证过滤器包括UsernamePasswordAuthenticationFilter、AnonymousAuthenticationFilter，它们会根据用户的请求信息赋予用户对应的身份
> ![认证](authentication.png)

经过认证等一系列过滤器后，进入到最后的出口过滤器FilterSecurityInterceptor，在该过滤器中，会将用户的请求信息和前面通过认证获得的authentication对象进行鉴权，判断用户是否有对应权限进行操作，本次的漏洞点就是在获取请求路径需要权限的getAttributes()方法部分
> org.springframework.security.access.intercept.AbstractSecurityInterceptor#beforeInvocation
> ![出口](interceptor.png)

### 漏洞点
在获取请求路径所需权限的getAttributes()方法中，会将配置与请求路径进行匹配，例如，匹配器为MvcRequestMatcher，路径为**
> org.springframework.security.web.access.intercept.DefaultFilterInvocationSecurityMetadataSource#getAttributes
> ![匹配](MvcRequestMatcher.png)

MvcRequestMatcher在匹配时又会调用HandlerMappingIntrospecotr的方法进行匹配
> org.springframework.security.web.servlet.util.matcher.MvcRequestMatcher#matches
> ![匹配](matchers.png)

HandlerMappingIntrospecotr在匹配时，首先会解析路径，包括请求路径和配置的认证路径，而后进行匹配
> org.springframework.web.servlet.handler.PathPatternMatchableHandlerMapping#match
> ![匹配](PathPatternMatchableHandlerMapping.png)

在匹配时会通过RegexPathElement进行正则匹配，首先获取textToMacth，对于/admin/page这个path第一个元素是/，此时会返回空字符串，而后与设置的模式进行正则匹配，\*\*被转化为了正则表达式.\*.\*
> org.springframework.web.util.pattern.RegexPathElement#matches
> ![匹配](RegexPathElement.png)

原本在正则匹配时.*可以匹配到空字符串，但是这里还有一个逻辑，首先pathIndex+1后明显小于matchingContext.pathLength，此时matches为false，再往下的逻辑，pathIndex+1后对应的元素并不是/，而是admin，此时匹配失败，请求路径无法对应到配置的\*\*认证路径，导致绕过
```java
if (matchers) {
    if (this.isNoMorePattern()) {
        if (!matchingContext.determineRemainingPath || !this.variableNames.isEmpty() && textToMatch.length() <= 0) {
            matches = pathIndex + 1 >= matchingContext.pathLength && (this.variableNames.isEmpty() || textToMatch.length() > 0);
            if (!matches && matchingContext.isMatchOptionalTrailingSeparator()) {
                matches = (this.variableNames.isEmpty() || textToMatch.length() > 0) && pathIndex + 2 >= matchingContext.pathLength && matchingContext.isSeparator(pathIndex + 1);
            }
        }
}
```

## 漏洞修复
在通过HandlerMappingIntrospector调用匹配方法前，加入了判断配置路径是否以/开头的语句，自动补全/
> org.springframework.web.servlet.handler.HandlerMappingIntrospector.PathSettingHandlerMapping#match
> ![修复](fix.png)

## 总结
该漏洞主要是由配置路径不严谨，预期和实际解析不一致导致
